#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import admin.ttypes

from thrift.transport import TTransport
all_structs = []


class ErrorCode(object):
    OTHER = 0
    DB_NOT_FOUND = 1
    ROCKSDB_ERROR = 2
    SEGMENT_NOT_FOUND = 3
    KEY_NOT_FOUND = 4
    ROUTING_ERROR = 5
    WRITE_TO_SLAVE = 6
    NUM_OVERFLOW = 7
    REQUEST_INVALID = 8
    THROTTLED = 9
    VERSION_EXPIRE = 10

    _VALUES_TO_NAMES = {
        0: "OTHER",
        1: "DB_NOT_FOUND",
        2: "ROCKSDB_ERROR",
        3: "SEGMENT_NOT_FOUND",
        4: "KEY_NOT_FOUND",
        5: "ROUTING_ERROR",
        6: "WRITE_TO_SLAVE",
        7: "NUM_OVERFLOW",
        8: "REQUEST_INVALID",
        9: "THROTTLED",
        10: "VERSION_EXPIRE",
    }

    _NAMES_TO_VALUES = {
        "OTHER": 0,
        "DB_NOT_FOUND": 1,
        "ROCKSDB_ERROR": 2,
        "SEGMENT_NOT_FOUND": 3,
        "KEY_NOT_FOUND": 4,
        "ROUTING_ERROR": 5,
        "WRITE_TO_SLAVE": 6,
        "NUM_OVERFLOW": 7,
        "REQUEST_INVALID": 8,
        "THROTTLED": 9,
        "VERSION_EXPIRE": 10,
    }


class StoreType(object):
    KV = 0
    COUNTER = 1
    DEDUP_SET = 2
    SET = 3
    HASH = 4
    ZSET = 5
    ZSET_IDX = 6
    HASHEX = 7
    OTHER = 8

    _VALUES_TO_NAMES = {
        0: "KV",
        1: "COUNTER",
        2: "DEDUP_SET",
        3: "SET",
        4: "HASH",
        5: "ZSET",
        6: "ZSET_IDX",
        7: "HASHEX",
        8: "OTHER",
    }

    _NAMES_TO_VALUES = {
        "KV": 0,
        "COUNTER": 1,
        "DEDUP_SET": 2,
        "SET": 3,
        "HASH": 4,
        "ZSET": 5,
        "ZSET_IDX": 6,
        "HASHEX": 7,
        "OTHER": 8,
    }


class HashType(object):
    STR = 0
    INT = 1
    BUF = 2

    _VALUES_TO_NAMES = {
        0: "STR",
        1: "INT",
        2: "BUF",
    }

    _NAMES_TO_VALUES = {
        "STR": 0,
        "INT": 1,
        "BUF": 2,
    }


class SharestoreException(TException):
    """
    Attributes:
     - message
     - code
    """


    def __init__(self, message=None, code=None,):
        self.message = message
        self.code = code

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SharestoreException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 2)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.message is None:
            raise TProtocolException(message='Required field message is unset!')
        if self.code is None:
            raise TProtocolException(message='Required field code is unset!')
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetRequest(object):
    """
    Attributes:
     - segment
     - key
     - need_routing
    """


    def __init__(self, segment="default", key=None, need_routing=True,):
        self.segment = segment
        self.key = key
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 3)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetResponse(object):
    """
    Attributes:
     - value
     - error
    """


    def __init__(self, value=None, error=None,):
        self.value = value
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.value = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.error = SharestoreException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetResponse')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 1)
            oprot.writeBinary(self.value)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 2)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.value is None:
            raise TProtocolException(message='Required field value is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MultiGetRequest(object):
    """
    Attributes:
     - segment
     - keys
     - index
     - need_routing
    """


    def __init__(self, segment="default", keys=None, index=None, need_routing=True,):
        self.segment = segment
        self.keys = keys
        self.index = index
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.index = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = iprot.readI32()
                        self.index.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MultiGetRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter12 in self.keys:
                oprot.writeString(iter12.encode('utf-8') if sys.version_info[0] == 2 else iter12)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.index))
            for iter13 in self.index:
                oprot.writeI32(iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 4)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.keys is None:
            raise TProtocolException(message='Required field keys is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MultiGetResponse(object):
    """
    Attributes:
     - responses
     - sub_request_indices
    """


    def __init__(self, responses=None, sub_request_indices=None,):
        self.responses = responses
        self.sub_request_indices = sub_request_indices

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.responses = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = GetResponse()
                        _elem19.read(iprot)
                        self.responses.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.sub_request_indices = []
                    (_etype23, _size20) = iprot.readListBegin()
                    for _i24 in range(_size20):
                        _elem25 = iprot.readI32()
                        self.sub_request_indices.append(_elem25)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MultiGetResponse')
        if self.responses is not None:
            oprot.writeFieldBegin('responses', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.responses))
            for iter26 in self.responses:
                iter26.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sub_request_indices is not None:
            oprot.writeFieldBegin('sub_request_indices', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.sub_request_indices))
            for iter27 in self.sub_request_indices:
                oprot.writeI32(iter27)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.responses is None:
            raise TProtocolException(message='Required field responses is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TtlRequest(object):
    """
    Attributes:
     - segment
     - key
     - need_routing
    """


    def __init__(self, segment="default", key=None, need_routing=True,):
        self.segment = segment
        self.key = key
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TtlRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 3)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TtlResponse(object):
    """
    Attributes:
     - ttl_sec
     - error
    """


    def __init__(self, ttl_sec=None, error=None,):
        self.ttl_sec = ttl_sec
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.ttl_sec = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.error = SharestoreException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TtlResponse')
        if self.ttl_sec is not None:
            oprot.writeFieldBegin('ttl_sec', TType.I32, 1)
            oprot.writeI32(self.ttl_sec)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 2)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.ttl_sec is None:
            raise TProtocolException(message='Required field ttl_sec is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SetRequest(object):
    """
    Attributes:
     - segment
     - key
     - value
     - ttl_sec
     - need_routing
    """


    def __init__(self, segment="default", key=None, value=None, ttl_sec=0, need_routing=True,):
        self.segment = segment
        self.key = key
        self.value = value
        self.ttl_sec = ttl_sec
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.ttl_sec = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeBinary(self.value)
            oprot.writeFieldEnd()
        if self.ttl_sec is not None:
            oprot.writeFieldBegin('ttl_sec', TType.I32, 4)
            oprot.writeI32(self.ttl_sec)
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 5)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        if self.value is None:
            raise TProtocolException(message='Required field value is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SetResponse(object):
    """
    Attributes:
     - error
    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SharestoreException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetResponse')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MultiSetRequest(object):
    """
    Attributes:
     - segment
     - keys
     - values
     - ttl_secs
     - index
     - need_routing
    """


    def __init__(self, segment="default", keys=None, values=None, ttl_secs=None, index=None, need_routing=True,):
        self.segment = segment
        self.keys = keys
        self.values = values
        self.ttl_secs = ttl_secs
        self.index = index
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype37, _size34) = iprot.readListBegin()
                    for _i38 in range(_size34):
                        _elem39 = iprot.readBinary()
                        self.values.append(_elem39)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.ttl_secs = []
                    (_etype43, _size40) = iprot.readListBegin()
                    for _i44 in range(_size40):
                        _elem45 = iprot.readI32()
                        self.ttl_secs.append(_elem45)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.index = []
                    (_etype49, _size46) = iprot.readListBegin()
                    for _i50 in range(_size46):
                        _elem51 = iprot.readI32()
                        self.index.append(_elem51)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MultiSetRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter52 in self.keys:
                oprot.writeString(iter52.encode('utf-8') if sys.version_info[0] == 2 else iter52)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.values))
            for iter53 in self.values:
                oprot.writeBinary(iter53)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ttl_secs is not None:
            oprot.writeFieldBegin('ttl_secs', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.ttl_secs))
            for iter54 in self.ttl_secs:
                oprot.writeI32(iter54)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.LIST, 5)
            oprot.writeListBegin(TType.I32, len(self.index))
            for iter55 in self.index:
                oprot.writeI32(iter55)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 6)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.keys is None:
            raise TProtocolException(message='Required field keys is unset!')
        if self.values is None:
            raise TProtocolException(message='Required field values is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MultiSetResponse(object):
    """
    Attributes:
     - responses
     - sub_request_indices
    """


    def __init__(self, responses=None, sub_request_indices=None,):
        self.responses = responses
        self.sub_request_indices = sub_request_indices

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.responses = []
                    (_etype59, _size56) = iprot.readListBegin()
                    for _i60 in range(_size56):
                        _elem61 = SetResponse()
                        _elem61.read(iprot)
                        self.responses.append(_elem61)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.sub_request_indices = []
                    (_etype65, _size62) = iprot.readListBegin()
                    for _i66 in range(_size62):
                        _elem67 = iprot.readI32()
                        self.sub_request_indices.append(_elem67)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MultiSetResponse')
        if self.responses is not None:
            oprot.writeFieldBegin('responses', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.responses))
            for iter68 in self.responses:
                iter68.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sub_request_indices is not None:
            oprot.writeFieldBegin('sub_request_indices', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.sub_request_indices))
            for iter69 in self.sub_request_indices:
                oprot.writeI32(iter69)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.responses is None:
            raise TProtocolException(message='Required field responses is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DelRequest(object):
    """
    Attributes:
     - segment
     - key
     - need_routing
    """


    def __init__(self, segment="default", key=None, need_routing=True,):
        self.segment = segment
        self.key = key
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DelRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 3)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DelResponse(object):
    """
    Attributes:
     - error
    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SharestoreException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DelResponse')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DSSetRequest(object):
    """
    Attributes:
     - segment
     - key
     - members
     - ttl_secs
     - need_routing
    """


    def __init__(self, segment="default", key=None, members=None, ttl_secs=None, need_routing=True,):
        self.segment = segment
        self.key = key
        self.members = members
        self.ttl_secs = ttl_secs
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.members = []
                    (_etype73, _size70) = iprot.readListBegin()
                    for _i74 in range(_size70):
                        _elem75 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.members.append(_elem75)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.ttl_secs = []
                    (_etype79, _size76) = iprot.readListBegin()
                    for _i80 in range(_size76):
                        _elem81 = iprot.readI32()
                        self.ttl_secs.append(_elem81)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DSSetRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.members is not None:
            oprot.writeFieldBegin('members', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.members))
            for iter82 in self.members:
                oprot.writeString(iter82.encode('utf-8') if sys.version_info[0] == 2 else iter82)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ttl_secs is not None:
            oprot.writeFieldBegin('ttl_secs', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.ttl_secs))
            for iter83 in self.ttl_secs:
                oprot.writeI32(iter83)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 5)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        if self.members is None:
            raise TProtocolException(message='Required field members is unset!')
        if self.ttl_secs is None:
            raise TProtocolException(message='Required field ttl_secs is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DSSetResponse(object):
    """
    Attributes:
     - error
    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SharestoreException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DSSetResponse')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DSRemRequest(object):
    """
    Attributes:
     - segment
     - key
     - members
     - need_routing
    """


    def __init__(self, segment="default", key=None, members=None, need_routing=True,):
        self.segment = segment
        self.key = key
        self.members = members
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.members = []
                    (_etype87, _size84) = iprot.readListBegin()
                    for _i88 in range(_size84):
                        _elem89 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.members.append(_elem89)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DSRemRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.members is not None:
            oprot.writeFieldBegin('members', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.members))
            for iter90 in self.members:
                oprot.writeString(iter90.encode('utf-8') if sys.version_info[0] == 2 else iter90)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 4)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        if self.members is None:
            raise TProtocolException(message='Required field members is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DSRemResponse(object):
    """
    Attributes:
     - error
    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SharestoreException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DSRemResponse')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DSGetRequest(object):
    """
    Attributes:
     - segment
     - key
     - with_ttls
     - need_routing
     - max_nums
    """


    def __init__(self, segment="default", key=None, with_ttls=False, need_routing=True, max_nums=5000,):
        self.segment = segment
        self.key = key
        self.with_ttls = with_ttls
        self.need_routing = need_routing
        self.max_nums = max_nums

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.with_ttls = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.max_nums = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DSGetRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.with_ttls is not None:
            oprot.writeFieldBegin('with_ttls', TType.BOOL, 3)
            oprot.writeBool(self.with_ttls)
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 4)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        if self.max_nums is not None:
            oprot.writeFieldBegin('max_nums', TType.I32, 5)
            oprot.writeI32(self.max_nums)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DSGetResponse(object):
    """
    Attributes:
     - members
     - ttl_secs
     - error
    """


    def __init__(self, members=None, ttl_secs=None, error=None,):
        self.members = members
        self.ttl_secs = ttl_secs
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.members = []
                    (_etype94, _size91) = iprot.readListBegin()
                    for _i95 in range(_size91):
                        _elem96 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.members.append(_elem96)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.ttl_secs = []
                    (_etype100, _size97) = iprot.readListBegin()
                    for _i101 in range(_size97):
                        _elem102 = iprot.readI32()
                        self.ttl_secs.append(_elem102)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.error = SharestoreException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DSGetResponse')
        if self.members is not None:
            oprot.writeFieldBegin('members', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.members))
            for iter103 in self.members:
                oprot.writeString(iter103.encode('utf-8') if sys.version_info[0] == 2 else iter103)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ttl_secs is not None:
            oprot.writeFieldBegin('ttl_secs', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.ttl_secs))
            for iter104 in self.ttl_secs:
                oprot.writeI32(iter104)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 3)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.members is None:
            raise TProtocolException(message='Required field members is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DSCountRequest(object):
    """
    Attributes:
     - segment
     - key
     - need_routing
     - max_nums
    """


    def __init__(self, segment="default", key=None, need_routing=True, max_nums=5000,):
        self.segment = segment
        self.key = key
        self.need_routing = need_routing
        self.max_nums = max_nums

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.max_nums = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DSCountRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 3)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        if self.max_nums is not None:
            oprot.writeFieldBegin('max_nums', TType.I32, 4)
            oprot.writeI32(self.max_nums)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DSCountResponse(object):
    """
    Attributes:
     - count
     - error
    """


    def __init__(self, count=0, error=None,):
        self.count = count
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.error = SharestoreException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DSCountResponse')
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 1)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 2)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.count is None:
            raise TProtocolException(message='Required field count is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DSDelRequest(object):
    """
    Attributes:
     - segment
     - key
     - need_routing
    """


    def __init__(self, segment="default", key=None, need_routing=True,):
        self.segment = segment
        self.key = key
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DSDelRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 3)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DSDelResponse(object):
    """
    Attributes:
     - error
    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SharestoreException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DSDelResponse')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DSIsMemberRequest(object):
    """
    Attributes:
     - segment
     - key
     - member
     - need_routing
    """


    def __init__(self, segment="default", key=None, member=None, need_routing=True,):
        self.segment = segment
        self.key = key
        self.member = member
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.member = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DSIsMemberRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.member is not None:
            oprot.writeFieldBegin('member', TType.STRING, 3)
            oprot.writeString(self.member.encode('utf-8') if sys.version_info[0] == 2 else self.member)
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 4)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        if self.member is None:
            raise TProtocolException(message='Required field member is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DSIsMemberResponse(object):
    """
    Attributes:
     - yes
     - error
    """


    def __init__(self, yes=None, error=None,):
        self.yes = yes
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.yes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.error = SharestoreException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DSIsMemberResponse')
        if self.yes is not None:
            oprot.writeFieldBegin('yes', TType.BOOL, 1)
            oprot.writeBool(self.yes)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 2)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.yes is None:
            raise TProtocolException(message='Required field yes is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class IncrCounterRequest(object):
    """
    Attributes:
     - segment
     - key
     - value
     - need_routing
    """


    def __init__(self, segment="default", key=None, value=1, need_routing=True,):
        self.segment = segment
        self.key = key
        self.value = value
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.value = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('IncrCounterRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I64, 3)
            oprot.writeI64(self.value)
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 4)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        if self.value is None:
            raise TProtocolException(message='Required field value is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class IncrCounterTtlRequest(object):
    """
    Attributes:
     - segment
     - key
     - value
     - ttl_sec
     - need_routing
    """


    def __init__(self, segment="default", key=None, value=1, ttl_sec=None, need_routing=True,):
        self.segment = segment
        self.key = key
        self.value = value
        self.ttl_sec = ttl_sec
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.value = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.ttl_sec = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('IncrCounterTtlRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I64, 3)
            oprot.writeI64(self.value)
            oprot.writeFieldEnd()
        if self.ttl_sec is not None:
            oprot.writeFieldBegin('ttl_sec', TType.I32, 4)
            oprot.writeI32(self.ttl_sec)
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 5)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        if self.value is None:
            raise TProtocolException(message='Required field value is unset!')
        if self.ttl_sec is None:
            raise TProtocolException(message='Required field ttl_sec is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class IncrCounterResponse(object):
    """
    Attributes:
     - error
    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SharestoreException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('IncrCounterResponse')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MultiIncrCounterRequest(object):
    """
    Attributes:
     - segment
     - keys
     - values
     - index
     - need_routing
    """


    def __init__(self, segment="default", keys=None, values=None, index=None, need_routing=True,):
        self.segment = segment
        self.keys = keys
        self.values = values
        self.index = index
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype108, _size105) = iprot.readListBegin()
                    for _i109 in range(_size105):
                        _elem110 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem110)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype114, _size111) = iprot.readListBegin()
                    for _i115 in range(_size111):
                        _elem116 = iprot.readI64()
                        self.values.append(_elem116)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.index = []
                    (_etype120, _size117) = iprot.readListBegin()
                    for _i121 in range(_size117):
                        _elem122 = iprot.readI32()
                        self.index.append(_elem122)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MultiIncrCounterRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter123 in self.keys:
                oprot.writeString(iter123.encode('utf-8') if sys.version_info[0] == 2 else iter123)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 3)
            oprot.writeListBegin(TType.I64, len(self.values))
            for iter124 in self.values:
                oprot.writeI64(iter124)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.index))
            for iter125 in self.index:
                oprot.writeI32(iter125)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 5)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.keys is None:
            raise TProtocolException(message='Required field keys is unset!')
        if self.values is None:
            raise TProtocolException(message='Required field values is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MultiIncrCounterTtlRequest(object):
    """
    Attributes:
     - segment
     - keys
     - values
     - ttl_secs
     - index
     - need_routing
    """


    def __init__(self, segment="default", keys=None, values=None, ttl_secs=None, index=None, need_routing=True,):
        self.segment = segment
        self.keys = keys
        self.values = values
        self.ttl_secs = ttl_secs
        self.index = index
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype129, _size126) = iprot.readListBegin()
                    for _i130 in range(_size126):
                        _elem131 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem131)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype135, _size132) = iprot.readListBegin()
                    for _i136 in range(_size132):
                        _elem137 = iprot.readI64()
                        self.values.append(_elem137)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.ttl_secs = []
                    (_etype141, _size138) = iprot.readListBegin()
                    for _i142 in range(_size138):
                        _elem143 = iprot.readI32()
                        self.ttl_secs.append(_elem143)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.index = []
                    (_etype147, _size144) = iprot.readListBegin()
                    for _i148 in range(_size144):
                        _elem149 = iprot.readI32()
                        self.index.append(_elem149)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MultiIncrCounterTtlRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter150 in self.keys:
                oprot.writeString(iter150.encode('utf-8') if sys.version_info[0] == 2 else iter150)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 3)
            oprot.writeListBegin(TType.I64, len(self.values))
            for iter151 in self.values:
                oprot.writeI64(iter151)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ttl_secs is not None:
            oprot.writeFieldBegin('ttl_secs', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.ttl_secs))
            for iter152 in self.ttl_secs:
                oprot.writeI32(iter152)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.LIST, 5)
            oprot.writeListBegin(TType.I32, len(self.index))
            for iter153 in self.index:
                oprot.writeI32(iter153)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 6)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.keys is None:
            raise TProtocolException(message='Required field keys is unset!')
        if self.values is None:
            raise TProtocolException(message='Required field values is unset!')
        if self.ttl_secs is None:
            raise TProtocolException(message='Required field ttl_secs is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MultiIncrCounterResponse(object):
    """
    Attributes:
     - responses
     - sub_request_indices
    """


    def __init__(self, responses=None, sub_request_indices=None,):
        self.responses = responses
        self.sub_request_indices = sub_request_indices

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.responses = []
                    (_etype157, _size154) = iprot.readListBegin()
                    for _i158 in range(_size154):
                        _elem159 = IncrCounterResponse()
                        _elem159.read(iprot)
                        self.responses.append(_elem159)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.sub_request_indices = []
                    (_etype163, _size160) = iprot.readListBegin()
                    for _i164 in range(_size160):
                        _elem165 = iprot.readI32()
                        self.sub_request_indices.append(_elem165)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MultiIncrCounterResponse')
        if self.responses is not None:
            oprot.writeFieldBegin('responses', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.responses))
            for iter166 in self.responses:
                iter166.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sub_request_indices is not None:
            oprot.writeFieldBegin('sub_request_indices', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.sub_request_indices))
            for iter167 in self.sub_request_indices:
                oprot.writeI32(iter167)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.responses is None:
            raise TProtocolException(message='Required field responses is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetCounterRequest(object):
    """
    Attributes:
     - segment
     - key
     - need_routing
    """


    def __init__(self, segment="default", key=None, need_routing=True,):
        self.segment = segment
        self.key = key
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetCounterRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 3)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetCounterResponse(object):
    """
    Attributes:
     - value
     - error
    """


    def __init__(self, value=None, error=None,):
        self.value = value
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.value = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.error = SharestoreException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetCounterResponse')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I64, 1)
            oprot.writeI64(self.value)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 2)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.value is None:
            raise TProtocolException(message='Required field value is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SetCounterRequest(object):
    """
    Attributes:
     - segment
     - key
     - value
     - need_routing
    """


    def __init__(self, segment="default", key=None, value=None, need_routing=True,):
        self.segment = segment
        self.key = key
        self.value = value
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.value = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetCounterRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I64, 3)
            oprot.writeI64(self.value)
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 4)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        if self.value is None:
            raise TProtocolException(message='Required field value is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SetCounterTtlRequest(object):
    """
    Attributes:
     - segment
     - key
     - value
     - ttl_sec
     - need_routing
    """


    def __init__(self, segment="default", key=None, value=None, ttl_sec=None, need_routing=True,):
        self.segment = segment
        self.key = key
        self.value = value
        self.ttl_sec = ttl_sec
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.value = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.ttl_sec = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetCounterTtlRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I64, 3)
            oprot.writeI64(self.value)
            oprot.writeFieldEnd()
        if self.ttl_sec is not None:
            oprot.writeFieldBegin('ttl_sec', TType.I32, 4)
            oprot.writeI32(self.ttl_sec)
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 5)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        if self.value is None:
            raise TProtocolException(message='Required field value is unset!')
        if self.ttl_sec is None:
            raise TProtocolException(message='Required field ttl_sec is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SetCounterResponse(object):
    """
    Attributes:
     - error
    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SharestoreException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SetCounterResponse')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MultiSetCounterRequest(object):
    """
    Attributes:
     - segment
     - keys
     - values
     - index
     - need_routing
    """


    def __init__(self, segment="default", keys=None, values=None, index=None, need_routing=True,):
        self.segment = segment
        self.keys = keys
        self.values = values
        self.index = index
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype171, _size168) = iprot.readListBegin()
                    for _i172 in range(_size168):
                        _elem173 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem173)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype177, _size174) = iprot.readListBegin()
                    for _i178 in range(_size174):
                        _elem179 = iprot.readI64()
                        self.values.append(_elem179)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.index = []
                    (_etype183, _size180) = iprot.readListBegin()
                    for _i184 in range(_size180):
                        _elem185 = iprot.readI32()
                        self.index.append(_elem185)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MultiSetCounterRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter186 in self.keys:
                oprot.writeString(iter186.encode('utf-8') if sys.version_info[0] == 2 else iter186)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 3)
            oprot.writeListBegin(TType.I64, len(self.values))
            for iter187 in self.values:
                oprot.writeI64(iter187)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.index))
            for iter188 in self.index:
                oprot.writeI32(iter188)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 5)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.keys is None:
            raise TProtocolException(message='Required field keys is unset!')
        if self.values is None:
            raise TProtocolException(message='Required field values is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MultiSetCounterTtlRequest(object):
    """
    Attributes:
     - segment
     - keys
     - values
     - ttl_secs
     - index
     - need_routing
    """


    def __init__(self, segment="default", keys=None, values=None, ttl_secs=None, index=None, need_routing=True,):
        self.segment = segment
        self.keys = keys
        self.values = values
        self.ttl_secs = ttl_secs
        self.index = index
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype192, _size189) = iprot.readListBegin()
                    for _i193 in range(_size189):
                        _elem194 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem194)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype198, _size195) = iprot.readListBegin()
                    for _i199 in range(_size195):
                        _elem200 = iprot.readI64()
                        self.values.append(_elem200)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.ttl_secs = []
                    (_etype204, _size201) = iprot.readListBegin()
                    for _i205 in range(_size201):
                        _elem206 = iprot.readI32()
                        self.ttl_secs.append(_elem206)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.index = []
                    (_etype210, _size207) = iprot.readListBegin()
                    for _i211 in range(_size207):
                        _elem212 = iprot.readI32()
                        self.index.append(_elem212)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MultiSetCounterTtlRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter213 in self.keys:
                oprot.writeString(iter213.encode('utf-8') if sys.version_info[0] == 2 else iter213)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 3)
            oprot.writeListBegin(TType.I64, len(self.values))
            for iter214 in self.values:
                oprot.writeI64(iter214)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ttl_secs is not None:
            oprot.writeFieldBegin('ttl_secs', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.ttl_secs))
            for iter215 in self.ttl_secs:
                oprot.writeI32(iter215)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.LIST, 5)
            oprot.writeListBegin(TType.I32, len(self.index))
            for iter216 in self.index:
                oprot.writeI32(iter216)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 6)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.keys is None:
            raise TProtocolException(message='Required field keys is unset!')
        if self.values is None:
            raise TProtocolException(message='Required field values is unset!')
        if self.ttl_secs is None:
            raise TProtocolException(message='Required field ttl_secs is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MultiSetCounterResponse(object):
    """
    Attributes:
     - responses
     - sub_request_indices
    """


    def __init__(self, responses=None, sub_request_indices=None,):
        self.responses = responses
        self.sub_request_indices = sub_request_indices

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.responses = []
                    (_etype220, _size217) = iprot.readListBegin()
                    for _i221 in range(_size217):
                        _elem222 = SetCounterResponse()
                        _elem222.read(iprot)
                        self.responses.append(_elem222)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.sub_request_indices = []
                    (_etype226, _size223) = iprot.readListBegin()
                    for _i227 in range(_size223):
                        _elem228 = iprot.readI32()
                        self.sub_request_indices.append(_elem228)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MultiSetCounterResponse')
        if self.responses is not None:
            oprot.writeFieldBegin('responses', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.responses))
            for iter229 in self.responses:
                iter229.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sub_request_indices is not None:
            oprot.writeFieldBegin('sub_request_indices', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.sub_request_indices))
            for iter230 in self.sub_request_indices:
                oprot.writeI32(iter230)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.responses is None:
            raise TProtocolException(message='Required field responses is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MultiGetCounterRequest(object):
    """
    Attributes:
     - segment
     - keys
     - index
     - need_routing
    """


    def __init__(self, segment="default", keys=None, index=None, need_routing=True,):
        self.segment = segment
        self.keys = keys
        self.index = index
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype234, _size231) = iprot.readListBegin()
                    for _i235 in range(_size231):
                        _elem236 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem236)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.index = []
                    (_etype240, _size237) = iprot.readListBegin()
                    for _i241 in range(_size237):
                        _elem242 = iprot.readI32()
                        self.index.append(_elem242)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MultiGetCounterRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter243 in self.keys:
                oprot.writeString(iter243.encode('utf-8') if sys.version_info[0] == 2 else iter243)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.index))
            for iter244 in self.index:
                oprot.writeI32(iter244)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 4)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.keys is None:
            raise TProtocolException(message='Required field keys is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MultiGetCounterResponse(object):
    """
    Attributes:
     - responses
     - sub_request_indices
    """


    def __init__(self, responses=None, sub_request_indices=None,):
        self.responses = responses
        self.sub_request_indices = sub_request_indices

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.responses = []
                    (_etype248, _size245) = iprot.readListBegin()
                    for _i249 in range(_size245):
                        _elem250 = GetCounterResponse()
                        _elem250.read(iprot)
                        self.responses.append(_elem250)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.sub_request_indices = []
                    (_etype254, _size251) = iprot.readListBegin()
                    for _i255 in range(_size251):
                        _elem256 = iprot.readI32()
                        self.sub_request_indices.append(_elem256)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MultiGetCounterResponse')
        if self.responses is not None:
            oprot.writeFieldBegin('responses', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.responses))
            for iter257 in self.responses:
                iter257.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sub_request_indices is not None:
            oprot.writeFieldBegin('sub_request_indices', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.sub_request_indices))
            for iter258 in self.sub_request_indices:
                oprot.writeI32(iter258)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.responses is None:
            raise TProtocolException(message='Required field responses is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HashValue(object):
    """
    Attributes:
     - str_val
     - int_val
     - buf_val
    """


    def __init__(self, str_val=None, int_val=None, buf_val=None,):
        self.str_val = str_val
        self.int_val = int_val
        self.buf_val = buf_val

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.str_val = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.int_val = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.buf_val = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HashValue')
        if self.str_val is not None:
            oprot.writeFieldBegin('str_val', TType.STRING, 1)
            oprot.writeString(self.str_val.encode('utf-8') if sys.version_info[0] == 2 else self.str_val)
            oprot.writeFieldEnd()
        if self.int_val is not None:
            oprot.writeFieldBegin('int_val', TType.I64, 2)
            oprot.writeI64(self.int_val)
            oprot.writeFieldEnd()
        if self.buf_val is not None:
            oprot.writeFieldBegin('buf_val', TType.STRING, 3)
            oprot.writeBinary(self.buf_val)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HashSetRequest(object):
    """
    Attributes:
     - segment
     - key
     - members
     - values
     - ttl_secs
     - need_routing
    """


    def __init__(self, segment="default", key=None, members=None, values=None, ttl_secs=None, need_routing=True,):
        self.segment = segment
        self.key = key
        self.members = members
        self.values = values
        self.ttl_secs = ttl_secs
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.members = []
                    (_etype262, _size259) = iprot.readListBegin()
                    for _i263 in range(_size259):
                        _elem264 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.members.append(_elem264)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype268, _size265) = iprot.readListBegin()
                    for _i269 in range(_size265):
                        _elem270 = HashValue()
                        _elem270.read(iprot)
                        self.values.append(_elem270)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.ttl_secs = []
                    (_etype274, _size271) = iprot.readListBegin()
                    for _i275 in range(_size271):
                        _elem276 = iprot.readI32()
                        self.ttl_secs.append(_elem276)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HashSetRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.members is not None:
            oprot.writeFieldBegin('members', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.members))
            for iter277 in self.members:
                oprot.writeString(iter277.encode('utf-8') if sys.version_info[0] == 2 else iter277)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.values))
            for iter278 in self.values:
                iter278.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ttl_secs is not None:
            oprot.writeFieldBegin('ttl_secs', TType.LIST, 5)
            oprot.writeListBegin(TType.I32, len(self.ttl_secs))
            for iter279 in self.ttl_secs:
                oprot.writeI32(iter279)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 6)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        if self.members is None:
            raise TProtocolException(message='Required field members is unset!')
        if self.values is None:
            raise TProtocolException(message='Required field values is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HashSetResponse(object):
    """
    Attributes:
     - error
    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SharestoreException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HashSetResponse')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MultiHashSetRequest(object):
    """
    Attributes:
     - segment
     - keys
     - members
     - values
     - ttl_secs
     - index
     - need_routing
    """


    def __init__(self, segment="default", keys=None, members=None, values=None, ttl_secs=None, index=None, need_routing=True,):
        self.segment = segment
        self.keys = keys
        self.members = members
        self.values = values
        self.ttl_secs = ttl_secs
        self.index = index
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype283, _size280) = iprot.readListBegin()
                    for _i284 in range(_size280):
                        _elem285 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem285)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.members = []
                    (_etype289, _size286) = iprot.readListBegin()
                    for _i290 in range(_size286):
                        _elem291 = []
                        (_etype295, _size292) = iprot.readListBegin()
                        for _i296 in range(_size292):
                            _elem297 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _elem291.append(_elem297)
                        iprot.readListEnd()
                        self.members.append(_elem291)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype301, _size298) = iprot.readListBegin()
                    for _i302 in range(_size298):
                        _elem303 = []
                        (_etype307, _size304) = iprot.readListBegin()
                        for _i308 in range(_size304):
                            _elem309 = HashValue()
                            _elem309.read(iprot)
                            _elem303.append(_elem309)
                        iprot.readListEnd()
                        self.values.append(_elem303)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.ttl_secs = []
                    (_etype313, _size310) = iprot.readListBegin()
                    for _i314 in range(_size310):
                        _elem315 = []
                        (_etype319, _size316) = iprot.readListBegin()
                        for _i320 in range(_size316):
                            _elem321 = iprot.readI32()
                            _elem315.append(_elem321)
                        iprot.readListEnd()
                        self.ttl_secs.append(_elem315)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.index = []
                    (_etype325, _size322) = iprot.readListBegin()
                    for _i326 in range(_size322):
                        _elem327 = iprot.readI32()
                        self.index.append(_elem327)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MultiHashSetRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter328 in self.keys:
                oprot.writeString(iter328.encode('utf-8') if sys.version_info[0] == 2 else iter328)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.members is not None:
            oprot.writeFieldBegin('members', TType.LIST, 3)
            oprot.writeListBegin(TType.LIST, len(self.members))
            for iter329 in self.members:
                oprot.writeListBegin(TType.STRING, len(iter329))
                for iter330 in iter329:
                    oprot.writeString(iter330.encode('utf-8') if sys.version_info[0] == 2 else iter330)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 4)
            oprot.writeListBegin(TType.LIST, len(self.values))
            for iter331 in self.values:
                oprot.writeListBegin(TType.STRUCT, len(iter331))
                for iter332 in iter331:
                    iter332.write(oprot)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ttl_secs is not None:
            oprot.writeFieldBegin('ttl_secs', TType.LIST, 5)
            oprot.writeListBegin(TType.LIST, len(self.ttl_secs))
            for iter333 in self.ttl_secs:
                oprot.writeListBegin(TType.I32, len(iter333))
                for iter334 in iter333:
                    oprot.writeI32(iter334)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.LIST, 6)
            oprot.writeListBegin(TType.I32, len(self.index))
            for iter335 in self.index:
                oprot.writeI32(iter335)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 7)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.keys is None:
            raise TProtocolException(message='Required field keys is unset!')
        if self.members is None:
            raise TProtocolException(message='Required field members is unset!')
        if self.values is None:
            raise TProtocolException(message='Required field values is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MultiHashSetResponse(object):
    """
    Attributes:
     - responses
     - sub_request_indices
    """


    def __init__(self, responses=None, sub_request_indices=None,):
        self.responses = responses
        self.sub_request_indices = sub_request_indices

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.responses = []
                    (_etype339, _size336) = iprot.readListBegin()
                    for _i340 in range(_size336):
                        _elem341 = HashSetResponse()
                        _elem341.read(iprot)
                        self.responses.append(_elem341)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.sub_request_indices = []
                    (_etype345, _size342) = iprot.readListBegin()
                    for _i346 in range(_size342):
                        _elem347 = iprot.readI32()
                        self.sub_request_indices.append(_elem347)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MultiHashSetResponse')
        if self.responses is not None:
            oprot.writeFieldBegin('responses', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.responses))
            for iter348 in self.responses:
                iter348.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sub_request_indices is not None:
            oprot.writeFieldBegin('sub_request_indices', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.sub_request_indices))
            for iter349 in self.sub_request_indices:
                oprot.writeI32(iter349)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.responses is None:
            raise TProtocolException(message='Required field responses is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HashRemRequest(object):
    """
    Attributes:
     - segment
     - key
     - type
     - members
     - need_routing
    """


    def __init__(self, segment="default", key=None, type=0, members=None, need_routing=True,):
        self.segment = segment
        self.key = key
        self.type = type
        self.members = members
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.members = []
                    (_etype353, _size350) = iprot.readListBegin()
                    for _i354 in range(_size350):
                        _elem355 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.members.append(_elem355)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HashRemRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 3)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.members is not None:
            oprot.writeFieldBegin('members', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.members))
            for iter356 in self.members:
                oprot.writeString(iter356.encode('utf-8') if sys.version_info[0] == 2 else iter356)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 5)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HashRemResponse(object):
    """
    Attributes:
     - error
    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SharestoreException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HashRemResponse')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MultiHashRemRequest(object):
    """
    Attributes:
     - segment
     - keys
     - types
     - members
     - index
     - need_routing
    """


    def __init__(self, segment="default", keys=None, types=[
    ], members=None, index=None, need_routing=True,):
        self.segment = segment
        self.keys = keys
        if types is self.thrift_spec[3][4]:
            types = [
            ]
        self.types = types
        self.members = members
        self.index = index
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype360, _size357) = iprot.readListBegin()
                    for _i361 in range(_size357):
                        _elem362 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem362)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.types = []
                    (_etype366, _size363) = iprot.readListBegin()
                    for _i367 in range(_size363):
                        _elem368 = iprot.readI32()
                        self.types.append(_elem368)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.members = []
                    (_etype372, _size369) = iprot.readListBegin()
                    for _i373 in range(_size369):
                        _elem374 = []
                        (_etype378, _size375) = iprot.readListBegin()
                        for _i379 in range(_size375):
                            _elem380 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _elem374.append(_elem380)
                        iprot.readListEnd()
                        self.members.append(_elem374)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.index = []
                    (_etype384, _size381) = iprot.readListBegin()
                    for _i385 in range(_size381):
                        _elem386 = iprot.readI32()
                        self.index.append(_elem386)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MultiHashRemRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter387 in self.keys:
                oprot.writeString(iter387.encode('utf-8') if sys.version_info[0] == 2 else iter387)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.types is not None:
            oprot.writeFieldBegin('types', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.types))
            for iter388 in self.types:
                oprot.writeI32(iter388)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.members is not None:
            oprot.writeFieldBegin('members', TType.LIST, 4)
            oprot.writeListBegin(TType.LIST, len(self.members))
            for iter389 in self.members:
                oprot.writeListBegin(TType.STRING, len(iter389))
                for iter390 in iter389:
                    oprot.writeString(iter390.encode('utf-8') if sys.version_info[0] == 2 else iter390)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.LIST, 5)
            oprot.writeListBegin(TType.I32, len(self.index))
            for iter391 in self.index:
                oprot.writeI32(iter391)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 6)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.keys is None:
            raise TProtocolException(message='Required field keys is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MultiHashRemResponse(object):
    """
    Attributes:
     - responses
     - sub_request_indices
    """


    def __init__(self, responses=None, sub_request_indices=None,):
        self.responses = responses
        self.sub_request_indices = sub_request_indices

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.responses = []
                    (_etype395, _size392) = iprot.readListBegin()
                    for _i396 in range(_size392):
                        _elem397 = HashRemResponse()
                        _elem397.read(iprot)
                        self.responses.append(_elem397)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.sub_request_indices = []
                    (_etype401, _size398) = iprot.readListBegin()
                    for _i402 in range(_size398):
                        _elem403 = iprot.readI32()
                        self.sub_request_indices.append(_elem403)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MultiHashRemResponse')
        if self.responses is not None:
            oprot.writeFieldBegin('responses', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.responses))
            for iter404 in self.responses:
                iter404.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sub_request_indices is not None:
            oprot.writeFieldBegin('sub_request_indices', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.sub_request_indices))
            for iter405 in self.sub_request_indices:
                oprot.writeI32(iter405)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.responses is None:
            raise TProtocolException(message='Required field responses is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HashGetRequest(object):
    """
    Attributes:
     - segment
     - key
     - type
     - members
     - need_routing
     - max_nums
    """


    def __init__(self, segment="default", key=None, type=0, members=None, need_routing=True, max_nums=5000,):
        self.segment = segment
        self.key = key
        self.type = type
        self.members = members
        self.need_routing = need_routing
        self.max_nums = max_nums

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.members = []
                    (_etype409, _size406) = iprot.readListBegin()
                    for _i410 in range(_size406):
                        _elem411 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.members.append(_elem411)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.max_nums = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HashGetRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 3)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.members is not None:
            oprot.writeFieldBegin('members', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.members))
            for iter412 in self.members:
                oprot.writeString(iter412.encode('utf-8') if sys.version_info[0] == 2 else iter412)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 5)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        if self.max_nums is not None:
            oprot.writeFieldBegin('max_nums', TType.I32, 6)
            oprot.writeI32(self.max_nums)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HashGetResponse(object):
    """
    Attributes:
     - members
     - values
     - error
    """


    def __init__(self, members=None, values=None, error=None,):
        self.members = members
        self.values = values
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.members = []
                    (_etype416, _size413) = iprot.readListBegin()
                    for _i417 in range(_size413):
                        _elem418 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.members.append(_elem418)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype422, _size419) = iprot.readListBegin()
                    for _i423 in range(_size419):
                        _elem424 = HashValue()
                        _elem424.read(iprot)
                        self.values.append(_elem424)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.error = SharestoreException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HashGetResponse')
        if self.members is not None:
            oprot.writeFieldBegin('members', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.members))
            for iter425 in self.members:
                oprot.writeString(iter425.encode('utf-8') if sys.version_info[0] == 2 else iter425)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.values))
            for iter426 in self.values:
                iter426.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 3)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.members is None:
            raise TProtocolException(message='Required field members is unset!')
        if self.values is None:
            raise TProtocolException(message='Required field values is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MultiHashGetRequest(object):
    """
    Attributes:
     - segment
     - keys
     - types
     - members
     - max_nums
     - index
     - need_routing
    """


    def __init__(self, segment="default", keys=None, types=[
    ], members=None, max_nums=5000, index=None, need_routing=True,):
        self.segment = segment
        self.keys = keys
        if types is self.thrift_spec[3][4]:
            types = [
            ]
        self.types = types
        self.members = members
        self.max_nums = max_nums
        self.index = index
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype430, _size427) = iprot.readListBegin()
                    for _i431 in range(_size427):
                        _elem432 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem432)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.types = []
                    (_etype436, _size433) = iprot.readListBegin()
                    for _i437 in range(_size433):
                        _elem438 = iprot.readI32()
                        self.types.append(_elem438)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.members = []
                    (_etype442, _size439) = iprot.readListBegin()
                    for _i443 in range(_size439):
                        _elem444 = []
                        (_etype448, _size445) = iprot.readListBegin()
                        for _i449 in range(_size445):
                            _elem450 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _elem444.append(_elem450)
                        iprot.readListEnd()
                        self.members.append(_elem444)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.max_nums = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.index = []
                    (_etype454, _size451) = iprot.readListBegin()
                    for _i455 in range(_size451):
                        _elem456 = iprot.readI32()
                        self.index.append(_elem456)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MultiHashGetRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter457 in self.keys:
                oprot.writeString(iter457.encode('utf-8') if sys.version_info[0] == 2 else iter457)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.types is not None:
            oprot.writeFieldBegin('types', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.types))
            for iter458 in self.types:
                oprot.writeI32(iter458)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.members is not None:
            oprot.writeFieldBegin('members', TType.LIST, 4)
            oprot.writeListBegin(TType.LIST, len(self.members))
            for iter459 in self.members:
                oprot.writeListBegin(TType.STRING, len(iter459))
                for iter460 in iter459:
                    oprot.writeString(iter460.encode('utf-8') if sys.version_info[0] == 2 else iter460)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.max_nums is not None:
            oprot.writeFieldBegin('max_nums', TType.I32, 5)
            oprot.writeI32(self.max_nums)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.LIST, 6)
            oprot.writeListBegin(TType.I32, len(self.index))
            for iter461 in self.index:
                oprot.writeI32(iter461)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 7)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.keys is None:
            raise TProtocolException(message='Required field keys is unset!')
        if self.types is None:
            raise TProtocolException(message='Required field types is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MultiHashGetResponse(object):
    """
    Attributes:
     - responses
     - sub_request_indices
    """


    def __init__(self, responses=None, sub_request_indices=None,):
        self.responses = responses
        self.sub_request_indices = sub_request_indices

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.responses = []
                    (_etype465, _size462) = iprot.readListBegin()
                    for _i466 in range(_size462):
                        _elem467 = HashGetResponse()
                        _elem467.read(iprot)
                        self.responses.append(_elem467)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.sub_request_indices = []
                    (_etype471, _size468) = iprot.readListBegin()
                    for _i472 in range(_size468):
                        _elem473 = iprot.readI32()
                        self.sub_request_indices.append(_elem473)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MultiHashGetResponse')
        if self.responses is not None:
            oprot.writeFieldBegin('responses', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.responses))
            for iter474 in self.responses:
                iter474.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sub_request_indices is not None:
            oprot.writeFieldBegin('sub_request_indices', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.sub_request_indices))
            for iter475 in self.sub_request_indices:
                oprot.writeI32(iter475)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.responses is None:
            raise TProtocolException(message='Required field responses is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HashIncrRequest(object):
    """
    Attributes:
     - segment
     - key
     - members
     - values
     - need_routing
    """


    def __init__(self, segment="default", key=None, members=None, values=None, need_routing=True,):
        self.segment = segment
        self.key = key
        self.members = members
        self.values = values
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.members = []
                    (_etype479, _size476) = iprot.readListBegin()
                    for _i480 in range(_size476):
                        _elem481 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.members.append(_elem481)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype485, _size482) = iprot.readListBegin()
                    for _i486 in range(_size482):
                        _elem487 = iprot.readI64()
                        self.values.append(_elem487)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HashIncrRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.members is not None:
            oprot.writeFieldBegin('members', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.members))
            for iter488 in self.members:
                oprot.writeString(iter488.encode('utf-8') if sys.version_info[0] == 2 else iter488)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 4)
            oprot.writeListBegin(TType.I64, len(self.values))
            for iter489 in self.values:
                oprot.writeI64(iter489)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 5)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        if self.members is None:
            raise TProtocolException(message='Required field members is unset!')
        if self.values is None:
            raise TProtocolException(message='Required field values is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HashIncrResponse(object):
    """
    Attributes:
     - error
    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SharestoreException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HashIncrResponse')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HashCountRequest(object):
    """
    Attributes:
     - segment
     - key
     - type
     - need_routing
     - max_nums
    """


    def __init__(self, segment="default", key=None, type=0, need_routing=True, max_nums=5000,):
        self.segment = segment
        self.key = key
        self.type = type
        self.need_routing = need_routing
        self.max_nums = max_nums

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.max_nums = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HashCountRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 3)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 4)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        if self.max_nums is not None:
            oprot.writeFieldBegin('max_nums', TType.I32, 5)
            oprot.writeI32(self.max_nums)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HashCountResponse(object):
    """
    Attributes:
     - count
     - error
    """


    def __init__(self, count=0, error=None,):
        self.count = count
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.error = SharestoreException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HashCountResponse')
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 1)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 2)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.count is None:
            raise TProtocolException(message='Required field count is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HashExSetRequest(object):
    """
    Attributes:
     - segment
     - key
     - members
     - values
     - version
     - ttl_secs
     - need_routing
    """


    def __init__(self, segment="default", key=None, members=None, values=None, version=0, ttl_secs=None, need_routing=True,):
        self.segment = segment
        self.key = key
        self.members = members
        self.values = values
        self.version = version
        self.ttl_secs = ttl_secs
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.members = []
                    (_etype493, _size490) = iprot.readListBegin()
                    for _i494 in range(_size490):
                        _elem495 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.members.append(_elem495)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype499, _size496) = iprot.readListBegin()
                    for _i500 in range(_size496):
                        _elem501 = HashValue()
                        _elem501.read(iprot)
                        self.values.append(_elem501)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.version = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.ttl_secs = []
                    (_etype505, _size502) = iprot.readListBegin()
                    for _i506 in range(_size502):
                        _elem507 = iprot.readI32()
                        self.ttl_secs.append(_elem507)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HashExSetRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.members is not None:
            oprot.writeFieldBegin('members', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.members))
            for iter508 in self.members:
                oprot.writeString(iter508.encode('utf-8') if sys.version_info[0] == 2 else iter508)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.values))
            for iter509 in self.values:
                iter509.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.I64, 5)
            oprot.writeI64(self.version)
            oprot.writeFieldEnd()
        if self.ttl_secs is not None:
            oprot.writeFieldBegin('ttl_secs', TType.LIST, 6)
            oprot.writeListBegin(TType.I32, len(self.ttl_secs))
            for iter510 in self.ttl_secs:
                oprot.writeI32(iter510)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 7)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        if self.members is None:
            raise TProtocolException(message='Required field members is unset!')
        if self.values is None:
            raise TProtocolException(message='Required field values is unset!')
        if self.version is None:
            raise TProtocolException(message='Required field version is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HashExSetResponse(object):
    """
    Attributes:
     - version
     - error
    """


    def __init__(self, version=None, error=None,):
        self.version = version
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.version = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.error = SharestoreException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HashExSetResponse')
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.I64, 1)
            oprot.writeI64(self.version)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 2)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.version is None:
            raise TProtocolException(message='Required field version is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HashExRemRequest(object):
    """
    Attributes:
     - segment
     - key
     - type
     - version
     - members
     - need_routing
    """


    def __init__(self, segment="default", key=None, type=0, version=0, members=None, need_routing=True,):
        self.segment = segment
        self.key = key
        self.type = type
        self.version = version
        self.members = members
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.version = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.members = []
                    (_etype514, _size511) = iprot.readListBegin()
                    for _i515 in range(_size511):
                        _elem516 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.members.append(_elem516)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HashExRemRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 3)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.I64, 4)
            oprot.writeI64(self.version)
            oprot.writeFieldEnd()
        if self.members is not None:
            oprot.writeFieldBegin('members', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.members))
            for iter517 in self.members:
                oprot.writeString(iter517.encode('utf-8') if sys.version_info[0] == 2 else iter517)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 6)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        if self.version is None:
            raise TProtocolException(message='Required field version is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HashExRemResponse(object):
    """
    Attributes:
     - version
     - error
    """


    def __init__(self, version=0, error=None,):
        self.version = version
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.version = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.error = SharestoreException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HashExRemResponse')
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.I64, 1)
            oprot.writeI64(self.version)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 2)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.version is None:
            raise TProtocolException(message='Required field version is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HashExGetRequest(object):
    """
    Attributes:
     - segment
     - key
     - type
     - members
     - need_routing
     - max_nums
    """


    def __init__(self, segment="default", key=None, type=0, members=None, need_routing=True, max_nums=5000,):
        self.segment = segment
        self.key = key
        self.type = type
        self.members = members
        self.need_routing = need_routing
        self.max_nums = max_nums

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.members = []
                    (_etype521, _size518) = iprot.readListBegin()
                    for _i522 in range(_size518):
                        _elem523 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.members.append(_elem523)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.max_nums = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HashExGetRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 3)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.members is not None:
            oprot.writeFieldBegin('members', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.members))
            for iter524 in self.members:
                oprot.writeString(iter524.encode('utf-8') if sys.version_info[0] == 2 else iter524)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 5)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        if self.max_nums is not None:
            oprot.writeFieldBegin('max_nums', TType.I32, 6)
            oprot.writeI32(self.max_nums)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HashExGetResponse(object):
    """
    Attributes:
     - members
     - values
     - version
     - error
    """


    def __init__(self, members=None, values=None, version=None, error=None,):
        self.members = members
        self.values = values
        self.version = version
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.members = []
                    (_etype528, _size525) = iprot.readListBegin()
                    for _i529 in range(_size525):
                        _elem530 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.members.append(_elem530)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype534, _size531) = iprot.readListBegin()
                    for _i535 in range(_size531):
                        _elem536 = HashValue()
                        _elem536.read(iprot)
                        self.values.append(_elem536)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.version = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.error = SharestoreException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HashExGetResponse')
        if self.members is not None:
            oprot.writeFieldBegin('members', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.members))
            for iter537 in self.members:
                oprot.writeString(iter537.encode('utf-8') if sys.version_info[0] == 2 else iter537)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.values))
            for iter538 in self.values:
                iter538.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.I64, 3)
            oprot.writeI64(self.version)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 4)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.members is None:
            raise TProtocolException(message='Required field members is unset!')
        if self.values is None:
            raise TProtocolException(message='Required field values is unset!')
        if self.version is None:
            raise TProtocolException(message='Required field version is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HashExIncrRequest(object):
    """
    Attributes:
     - segment
     - key
     - members
     - values
     - version
     - need_routing
    """


    def __init__(self, segment="default", key=None, members=None, values=None, version=0, need_routing=True,):
        self.segment = segment
        self.key = key
        self.members = members
        self.values = values
        self.version = version
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.members = []
                    (_etype542, _size539) = iprot.readListBegin()
                    for _i543 in range(_size539):
                        _elem544 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.members.append(_elem544)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype548, _size545) = iprot.readListBegin()
                    for _i549 in range(_size545):
                        _elem550 = iprot.readI64()
                        self.values.append(_elem550)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.version = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HashExIncrRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.members is not None:
            oprot.writeFieldBegin('members', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.members))
            for iter551 in self.members:
                oprot.writeString(iter551.encode('utf-8') if sys.version_info[0] == 2 else iter551)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 4)
            oprot.writeListBegin(TType.I64, len(self.values))
            for iter552 in self.values:
                oprot.writeI64(iter552)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.I64, 5)
            oprot.writeI64(self.version)
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 6)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        if self.members is None:
            raise TProtocolException(message='Required field members is unset!')
        if self.values is None:
            raise TProtocolException(message='Required field values is unset!')
        if self.version is None:
            raise TProtocolException(message='Required field version is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HashExIncrResponse(object):
    """
    Attributes:
     - version
     - error
    """


    def __init__(self, version=None, error=None,):
        self.version = version
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.version = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.error = SharestoreException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HashExIncrResponse')
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.I64, 1)
            oprot.writeI64(self.version)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 2)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.version is None:
            raise TProtocolException(message='Required field version is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HashExCountRequest(object):
    """
    Attributes:
     - segment
     - key
     - type
     - version
     - need_routing
     - max_nums
    """


    def __init__(self, segment="default", key=None, type=0, version=0, need_routing=True, max_nums=5000,):
        self.segment = segment
        self.key = key
        self.type = type
        self.version = version
        self.need_routing = need_routing
        self.max_nums = max_nums

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.version = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.max_nums = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HashExCountRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 3)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.I64, 4)
            oprot.writeI64(self.version)
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 5)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        if self.max_nums is not None:
            oprot.writeFieldBegin('max_nums', TType.I32, 6)
            oprot.writeI32(self.max_nums)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        if self.version is None:
            raise TProtocolException(message='Required field version is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HashExCountResponse(object):
    """
    Attributes:
     - count
     - version
     - error
    """


    def __init__(self, count=0, version=None, error=None,):
        self.count = count
        self.version = version
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.version = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.error = SharestoreException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HashExCountResponse')
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 1)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.I64, 2)
            oprot.writeI64(self.version)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 3)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.count is None:
            raise TProtocolException(message='Required field count is unset!')
        if self.version is None:
            raise TProtocolException(message='Required field version is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ZSetAddRequest(object):
    """
    Attributes:
     - segment
     - key
     - members
     - scores
     - ttl_secs
     - need_routing
    """


    def __init__(self, segment="default", key=None, members=None, scores=None, ttl_secs=None, need_routing=True,):
        self.segment = segment
        self.key = key
        self.members = members
        self.scores = scores
        self.ttl_secs = ttl_secs
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.members = []
                    (_etype556, _size553) = iprot.readListBegin()
                    for _i557 in range(_size553):
                        _elem558 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.members.append(_elem558)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.scores = []
                    (_etype562, _size559) = iprot.readListBegin()
                    for _i563 in range(_size559):
                        _elem564 = iprot.readI64()
                        self.scores.append(_elem564)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.ttl_secs = []
                    (_etype568, _size565) = iprot.readListBegin()
                    for _i569 in range(_size565):
                        _elem570 = iprot.readI32()
                        self.ttl_secs.append(_elem570)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ZSetAddRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.members is not None:
            oprot.writeFieldBegin('members', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.members))
            for iter571 in self.members:
                oprot.writeString(iter571.encode('utf-8') if sys.version_info[0] == 2 else iter571)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.scores is not None:
            oprot.writeFieldBegin('scores', TType.LIST, 4)
            oprot.writeListBegin(TType.I64, len(self.scores))
            for iter572 in self.scores:
                oprot.writeI64(iter572)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ttl_secs is not None:
            oprot.writeFieldBegin('ttl_secs', TType.LIST, 5)
            oprot.writeListBegin(TType.I32, len(self.ttl_secs))
            for iter573 in self.ttl_secs:
                oprot.writeI32(iter573)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 6)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        if self.members is None:
            raise TProtocolException(message='Required field members is unset!')
        if self.scores is None:
            raise TProtocolException(message='Required field scores is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ZSetAddResponse(object):
    """
    Attributes:
     - error
    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SharestoreException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ZSetAddResponse')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ZSetRemRequest(object):
    """
    Attributes:
     - segment
     - key
     - members
     - need_routing
    """


    def __init__(self, segment="default", key=None, members=None, need_routing=True,):
        self.segment = segment
        self.key = key
        self.members = members
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.members = []
                    (_etype577, _size574) = iprot.readListBegin()
                    for _i578 in range(_size574):
                        _elem579 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.members.append(_elem579)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ZSetRemRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.members is not None:
            oprot.writeFieldBegin('members', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.members))
            for iter580 in self.members:
                oprot.writeString(iter580.encode('utf-8') if sys.version_info[0] == 2 else iter580)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 4)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ZSetRemResponse(object):
    """
    Attributes:
     - error
    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SharestoreException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ZSetRemResponse')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ZSetGetRequest(object):
    """
    Attributes:
     - segment
     - key
     - with_scores
     - members
     - need_routing
     - max_nums
    """


    def __init__(self, segment="default", key=None, with_scores=True, members=None, need_routing=True, max_nums=5000,):
        self.segment = segment
        self.key = key
        self.with_scores = with_scores
        self.members = members
        self.need_routing = need_routing
        self.max_nums = max_nums

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.with_scores = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.members = []
                    (_etype584, _size581) = iprot.readListBegin()
                    for _i585 in range(_size581):
                        _elem586 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.members.append(_elem586)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.max_nums = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ZSetGetRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.with_scores is not None:
            oprot.writeFieldBegin('with_scores', TType.BOOL, 3)
            oprot.writeBool(self.with_scores)
            oprot.writeFieldEnd()
        if self.members is not None:
            oprot.writeFieldBegin('members', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.members))
            for iter587 in self.members:
                oprot.writeString(iter587.encode('utf-8') if sys.version_info[0] == 2 else iter587)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 5)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        if self.max_nums is not None:
            oprot.writeFieldBegin('max_nums', TType.I32, 6)
            oprot.writeI32(self.max_nums)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        if self.with_scores is None:
            raise TProtocolException(message='Required field with_scores is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ZSetGetResponse(object):
    """
    Attributes:
     - members
     - scores
     - error
    """


    def __init__(self, members=None, scores=None, error=None,):
        self.members = members
        self.scores = scores
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.members = []
                    (_etype591, _size588) = iprot.readListBegin()
                    for _i592 in range(_size588):
                        _elem593 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.members.append(_elem593)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.scores = []
                    (_etype597, _size594) = iprot.readListBegin()
                    for _i598 in range(_size594):
                        _elem599 = iprot.readI64()
                        self.scores.append(_elem599)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.error = SharestoreException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ZSetGetResponse')
        if self.members is not None:
            oprot.writeFieldBegin('members', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.members))
            for iter600 in self.members:
                oprot.writeString(iter600.encode('utf-8') if sys.version_info[0] == 2 else iter600)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.scores is not None:
            oprot.writeFieldBegin('scores', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.scores))
            for iter601 in self.scores:
                oprot.writeI64(iter601)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 3)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.members is None:
            raise TProtocolException(message='Required field members is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class IndexRange(object):
    """
    Attributes:
     - start
     - stop
    """


    def __init__(self, start=0, stop=-1,):
        self.start = start
        self.stop = stop

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.stop = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('IndexRange')
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.I32, 1)
            oprot.writeI32(self.start)
            oprot.writeFieldEnd()
        if self.stop is not None:
            oprot.writeFieldBegin('stop', TType.I32, 2)
            oprot.writeI32(self.stop)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.start is None:
            raise TProtocolException(message='Required field start is unset!')
        if self.stop is None:
            raise TProtocolException(message='Required field stop is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ScoreRange(object):
    """
    Attributes:
     - min
     - max
    """


    def __init__(self, min=0, max=9223372036854775807,):
        self.min = min
        self.max = max

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.min = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.max = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ScoreRange')
        if self.min is not None:
            oprot.writeFieldBegin('min', TType.I64, 1)
            oprot.writeI64(self.min)
            oprot.writeFieldEnd()
        if self.max is not None:
            oprot.writeFieldBegin('max', TType.I64, 2)
            oprot.writeI64(self.max)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.min is None:
            raise TProtocolException(message='Required field min is unset!')
        if self.max is None:
            raise TProtocolException(message='Required field max is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ZSetGetRangeRequest(object):
    """
    Attributes:
     - segment
     - key
     - index_range
     - score_range
     - with_scores
     - need_routing
     - max_nums
    """


    def __init__(self, segment="default", key=None, index_range=None, score_range=None, with_scores=True, need_routing=True, max_nums=5000,):
        self.segment = segment
        self.key = key
        self.index_range = index_range
        self.score_range = score_range
        self.with_scores = with_scores
        self.need_routing = need_routing
        self.max_nums = max_nums

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.index_range = IndexRange()
                    self.index_range.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.score_range = ScoreRange()
                    self.score_range.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.with_scores = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.max_nums = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ZSetGetRangeRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 3)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.index_range is not None:
            oprot.writeFieldBegin('index_range', TType.STRUCT, 4)
            self.index_range.write(oprot)
            oprot.writeFieldEnd()
        if self.score_range is not None:
            oprot.writeFieldBegin('score_range', TType.STRUCT, 5)
            self.score_range.write(oprot)
            oprot.writeFieldEnd()
        if self.with_scores is not None:
            oprot.writeFieldBegin('with_scores', TType.BOOL, 6)
            oprot.writeBool(self.with_scores)
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 7)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        if self.max_nums is not None:
            oprot.writeFieldBegin('max_nums', TType.I32, 8)
            oprot.writeI32(self.max_nums)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ZSetGetRangeResponse(object):
    """
    Attributes:
     - members
     - scores
     - error
    """


    def __init__(self, members=None, scores=None, error=None,):
        self.members = members
        self.scores = scores
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.members = []
                    (_etype605, _size602) = iprot.readListBegin()
                    for _i606 in range(_size602):
                        _elem607 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.members.append(_elem607)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.scores = []
                    (_etype611, _size608) = iprot.readListBegin()
                    for _i612 in range(_size608):
                        _elem613 = iprot.readI64()
                        self.scores.append(_elem613)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.error = SharestoreException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ZSetGetRangeResponse')
        if self.members is not None:
            oprot.writeFieldBegin('members', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.members))
            for iter614 in self.members:
                oprot.writeString(iter614.encode('utf-8') if sys.version_info[0] == 2 else iter614)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.scores is not None:
            oprot.writeFieldBegin('scores', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.scores))
            for iter615 in self.scores:
                oprot.writeI64(iter615)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 3)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.members is None:
            raise TProtocolException(message='Required field members is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ZSetRemRangeRequest(object):
    """
    Attributes:
     - segment
     - key
     - index_range
     - score_range
     - need_routing
    """


    def __init__(self, segment="default", key=None, index_range=None, score_range=None, need_routing=True,):
        self.segment = segment
        self.key = key
        self.index_range = index_range
        self.score_range = score_range
        self.need_routing = need_routing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.index_range = IndexRange()
                    self.index_range.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.score_range = ScoreRange()
                    self.score_range.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ZSetRemRangeRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.index_range is not None:
            oprot.writeFieldBegin('index_range', TType.STRUCT, 3)
            self.index_range.write(oprot)
            oprot.writeFieldEnd()
        if self.score_range is not None:
            oprot.writeFieldBegin('score_range', TType.STRUCT, 4)
            self.score_range.write(oprot)
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 5)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ZSetRemRangeResponse(object):
    """
    Attributes:
     - error
    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = SharestoreException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ZSetRemRangeResponse')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ZSetCountRequest(object):
    """
    Attributes:
     - segment
     - key
     - need_routing
     - max_nums
    """


    def __init__(self, segment="default", key=None, need_routing=True, max_nums=5000,):
        self.segment = segment
        self.key = key
        self.need_routing = need_routing
        self.max_nums = max_nums

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.max_nums = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ZSetCountRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 3)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        if self.max_nums is not None:
            oprot.writeFieldBegin('max_nums', TType.I32, 4)
            oprot.writeI32(self.max_nums)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ZSetCountResponse(object):
    """
    Attributes:
     - count
     - error
    """


    def __init__(self, count=0, error=None,):
        self.count = count
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.error = SharestoreException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ZSetCountResponse')
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 1)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 2)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.count is None:
            raise TProtocolException(message='Required field count is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ZSetScanRequest(object):
    """
    Attributes:
     - segment
     - key
     - cursor
     - with_scores
     - is_reverse
     - need_routing
     - max_nums
    """


    def __init__(self, segment="default", key=None, cursor=None, with_scores=True, is_reverse=False, need_routing=True, max_nums=5000,):
        self.segment = segment
        self.key = key
        self.cursor = cursor
        self.with_scores = with_scores
        self.is_reverse = is_reverse
        self.need_routing = need_routing
        self.max_nums = max_nums

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.segment = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.cursor = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.with_scores = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.is_reverse = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.need_routing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.max_nums = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ZSetScanRequest')
        if self.segment is not None:
            oprot.writeFieldBegin('segment', TType.STRING, 1)
            oprot.writeString(self.segment.encode('utf-8') if sys.version_info[0] == 2 else self.segment)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.cursor is not None:
            oprot.writeFieldBegin('cursor', TType.STRING, 3)
            oprot.writeBinary(self.cursor)
            oprot.writeFieldEnd()
        if self.with_scores is not None:
            oprot.writeFieldBegin('with_scores', TType.BOOL, 4)
            oprot.writeBool(self.with_scores)
            oprot.writeFieldEnd()
        if self.is_reverse is not None:
            oprot.writeFieldBegin('is_reverse', TType.BOOL, 5)
            oprot.writeBool(self.is_reverse)
            oprot.writeFieldEnd()
        if self.need_routing is not None:
            oprot.writeFieldBegin('need_routing', TType.BOOL, 6)
            oprot.writeBool(self.need_routing)
            oprot.writeFieldEnd()
        if self.max_nums is not None:
            oprot.writeFieldBegin('max_nums', TType.I32, 7)
            oprot.writeI32(self.max_nums)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ZSetScanResponse(object):
    """
    Attributes:
     - members
     - scores
     - cursor
     - error
    """


    def __init__(self, members=None, scores=None, cursor=None, error=None,):
        self.members = members
        self.scores = scores
        self.cursor = cursor
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.members = []
                    (_etype619, _size616) = iprot.readListBegin()
                    for _i620 in range(_size616):
                        _elem621 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.members.append(_elem621)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.scores = []
                    (_etype625, _size622) = iprot.readListBegin()
                    for _i626 in range(_size622):
                        _elem627 = iprot.readI64()
                        self.scores.append(_elem627)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.cursor = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.error = SharestoreException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ZSetScanResponse')
        if self.members is not None:
            oprot.writeFieldBegin('members', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.members))
            for iter628 in self.members:
                oprot.writeString(iter628.encode('utf-8') if sys.version_info[0] == 2 else iter628)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.scores is not None:
            oprot.writeFieldBegin('scores', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.scores))
            for iter629 in self.scores:
                oprot.writeI64(iter629)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.cursor is not None:
            oprot.writeFieldBegin('cursor', TType.STRING, 3)
            oprot.writeBinary(self.cursor)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 4)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.members is None:
            raise TProtocolException(message='Required field members is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SharestoreException)
SharestoreException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
    (2, TType.I32, 'code', None, None, ),  # 2
)
all_structs.append(GetRequest)
GetRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'need_routing', None, True, ),  # 3
)
all_structs.append(GetResponse)
GetResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'value', 'BINARY', None, ),  # 1
    (2, TType.STRUCT, 'error', [SharestoreException, None], None, ),  # 2
)
all_structs.append(MultiGetRequest)
MultiGetRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'index', (TType.I32, None, False), None, ),  # 3
    (4, TType.BOOL, 'need_routing', None, True, ),  # 4
)
all_structs.append(MultiGetResponse)
MultiGetResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'responses', (TType.STRUCT, [GetResponse, None], False), None, ),  # 1
    (2, TType.LIST, 'sub_request_indices', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(TtlRequest)
TtlRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'need_routing', None, True, ),  # 3
)
all_structs.append(TtlResponse)
TtlResponse.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'ttl_sec', None, None, ),  # 1
    (2, TType.STRUCT, 'error', [SharestoreException, None], None, ),  # 2
)
all_structs.append(SetRequest)
SetRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'value', 'BINARY', None, ),  # 3
    (4, TType.I32, 'ttl_sec', None, 0, ),  # 4
    (5, TType.BOOL, 'need_routing', None, True, ),  # 5
)
all_structs.append(SetResponse)
SetResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [SharestoreException, None], None, ),  # 1
)
all_structs.append(MultiSetRequest)
MultiSetRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'values', (TType.STRING, 'BINARY', False), None, ),  # 3
    (4, TType.LIST, 'ttl_secs', (TType.I32, None, False), None, ),  # 4
    (5, TType.LIST, 'index', (TType.I32, None, False), None, ),  # 5
    (6, TType.BOOL, 'need_routing', None, True, ),  # 6
)
all_structs.append(MultiSetResponse)
MultiSetResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'responses', (TType.STRUCT, [SetResponse, None], False), None, ),  # 1
    (2, TType.LIST, 'sub_request_indices', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(DelRequest)
DelRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'need_routing', None, True, ),  # 3
)
all_structs.append(DelResponse)
DelResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [SharestoreException, None], None, ),  # 1
)
all_structs.append(DSSetRequest)
DSSetRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'members', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'ttl_secs', (TType.I32, None, False), None, ),  # 4
    (5, TType.BOOL, 'need_routing', None, True, ),  # 5
)
all_structs.append(DSSetResponse)
DSSetResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [SharestoreException, None], None, ),  # 1
)
all_structs.append(DSRemRequest)
DSRemRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'members', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.BOOL, 'need_routing', None, True, ),  # 4
)
all_structs.append(DSRemResponse)
DSRemResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [SharestoreException, None], None, ),  # 1
)
all_structs.append(DSGetRequest)
DSGetRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'with_ttls', None, False, ),  # 3
    (4, TType.BOOL, 'need_routing', None, True, ),  # 4
    (5, TType.I32, 'max_nums', None, 5000, ),  # 5
)
all_structs.append(DSGetResponse)
DSGetResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'members', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'ttl_secs', (TType.I32, None, False), None, ),  # 2
    (3, TType.STRUCT, 'error', [SharestoreException, None], None, ),  # 3
)
all_structs.append(DSCountRequest)
DSCountRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'need_routing', None, True, ),  # 3
    (4, TType.I32, 'max_nums', None, 5000, ),  # 4
)
all_structs.append(DSCountResponse)
DSCountResponse.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'count', None, 0, ),  # 1
    (2, TType.STRUCT, 'error', [SharestoreException, None], None, ),  # 2
)
all_structs.append(DSDelRequest)
DSDelRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'need_routing', None, True, ),  # 3
)
all_structs.append(DSDelResponse)
DSDelResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [SharestoreException, None], None, ),  # 1
)
all_structs.append(DSIsMemberRequest)
DSIsMemberRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'member', 'UTF8', None, ),  # 3
    (4, TType.BOOL, 'need_routing', None, True, ),  # 4
)
all_structs.append(DSIsMemberResponse)
DSIsMemberResponse.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'yes', None, None, ),  # 1
    (2, TType.STRUCT, 'error', [SharestoreException, None], None, ),  # 2
)
all_structs.append(IncrCounterRequest)
IncrCounterRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.I64, 'value', None, 1, ),  # 3
    (4, TType.BOOL, 'need_routing', None, True, ),  # 4
)
all_structs.append(IncrCounterTtlRequest)
IncrCounterTtlRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.I64, 'value', None, 1, ),  # 3
    (4, TType.I32, 'ttl_sec', None, None, ),  # 4
    (5, TType.BOOL, 'need_routing', None, True, ),  # 5
)
all_structs.append(IncrCounterResponse)
IncrCounterResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [SharestoreException, None], None, ),  # 1
)
all_structs.append(MultiIncrCounterRequest)
MultiIncrCounterRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'values', (TType.I64, None, False), None, ),  # 3
    (4, TType.LIST, 'index', (TType.I32, None, False), None, ),  # 4
    (5, TType.BOOL, 'need_routing', None, True, ),  # 5
)
all_structs.append(MultiIncrCounterTtlRequest)
MultiIncrCounterTtlRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'values', (TType.I64, None, False), None, ),  # 3
    (4, TType.LIST, 'ttl_secs', (TType.I32, None, False), None, ),  # 4
    (5, TType.LIST, 'index', (TType.I32, None, False), None, ),  # 5
    (6, TType.BOOL, 'need_routing', None, True, ),  # 6
)
all_structs.append(MultiIncrCounterResponse)
MultiIncrCounterResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'responses', (TType.STRUCT, [IncrCounterResponse, None], False), None, ),  # 1
    (2, TType.LIST, 'sub_request_indices', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(GetCounterRequest)
GetCounterRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'need_routing', None, True, ),  # 3
)
all_structs.append(GetCounterResponse)
GetCounterResponse.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'value', None, None, ),  # 1
    (2, TType.STRUCT, 'error', [SharestoreException, None], None, ),  # 2
)
all_structs.append(SetCounterRequest)
SetCounterRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.I64, 'value', None, None, ),  # 3
    (4, TType.BOOL, 'need_routing', None, True, ),  # 4
)
all_structs.append(SetCounterTtlRequest)
SetCounterTtlRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.I64, 'value', None, None, ),  # 3
    (4, TType.I32, 'ttl_sec', None, None, ),  # 4
    (5, TType.BOOL, 'need_routing', None, True, ),  # 5
)
all_structs.append(SetCounterResponse)
SetCounterResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [SharestoreException, None], None, ),  # 1
)
all_structs.append(MultiSetCounterRequest)
MultiSetCounterRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'values', (TType.I64, None, False), None, ),  # 3
    (4, TType.LIST, 'index', (TType.I32, None, False), None, ),  # 4
    (5, TType.BOOL, 'need_routing', None, True, ),  # 5
)
all_structs.append(MultiSetCounterTtlRequest)
MultiSetCounterTtlRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'values', (TType.I64, None, False), None, ),  # 3
    (4, TType.LIST, 'ttl_secs', (TType.I32, None, False), None, ),  # 4
    (5, TType.LIST, 'index', (TType.I32, None, False), None, ),  # 5
    (6, TType.BOOL, 'need_routing', None, True, ),  # 6
)
all_structs.append(MultiSetCounterResponse)
MultiSetCounterResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'responses', (TType.STRUCT, [SetCounterResponse, None], False), None, ),  # 1
    (2, TType.LIST, 'sub_request_indices', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(MultiGetCounterRequest)
MultiGetCounterRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'index', (TType.I32, None, False), None, ),  # 3
    (4, TType.BOOL, 'need_routing', None, True, ),  # 4
)
all_structs.append(MultiGetCounterResponse)
MultiGetCounterResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'responses', (TType.STRUCT, [GetCounterResponse, None], False), None, ),  # 1
    (2, TType.LIST, 'sub_request_indices', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(HashValue)
HashValue.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'str_val', 'UTF8', None, ),  # 1
    (2, TType.I64, 'int_val', None, None, ),  # 2
    (3, TType.STRING, 'buf_val', 'BINARY', None, ),  # 3
)
all_structs.append(HashSetRequest)
HashSetRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'members', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'values', (TType.STRUCT, [HashValue, None], False), None, ),  # 4
    (5, TType.LIST, 'ttl_secs', (TType.I32, None, False), None, ),  # 5
    (6, TType.BOOL, 'need_routing', None, True, ),  # 6
)
all_structs.append(HashSetResponse)
HashSetResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [SharestoreException, None], None, ),  # 1
)
all_structs.append(MultiHashSetRequest)
MultiHashSetRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'members', (TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 3
    (4, TType.LIST, 'values', (TType.LIST, (TType.STRUCT, [HashValue, None], False), False), None, ),  # 4
    (5, TType.LIST, 'ttl_secs', (TType.LIST, (TType.I32, None, False), False), None, ),  # 5
    (6, TType.LIST, 'index', (TType.I32, None, False), None, ),  # 6
    (7, TType.BOOL, 'need_routing', None, True, ),  # 7
)
all_structs.append(MultiHashSetResponse)
MultiHashSetResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'responses', (TType.STRUCT, [HashSetResponse, None], False), None, ),  # 1
    (2, TType.LIST, 'sub_request_indices', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(HashRemRequest)
HashRemRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.I32, 'type', None, 0, ),  # 3
    (4, TType.LIST, 'members', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.BOOL, 'need_routing', None, True, ),  # 5
)
all_structs.append(HashRemResponse)
HashRemResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [SharestoreException, None], None, ),  # 1
)
all_structs.append(MultiHashRemRequest)
MultiHashRemRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'types', (TType.I32, None, False), [
    ], ),  # 3
    (4, TType.LIST, 'members', (TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 4
    (5, TType.LIST, 'index', (TType.I32, None, False), None, ),  # 5
    (6, TType.BOOL, 'need_routing', None, True, ),  # 6
)
all_structs.append(MultiHashRemResponse)
MultiHashRemResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'responses', (TType.STRUCT, [HashRemResponse, None], False), None, ),  # 1
    (2, TType.LIST, 'sub_request_indices', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(HashGetRequest)
HashGetRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.I32, 'type', None, 0, ),  # 3
    (4, TType.LIST, 'members', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.BOOL, 'need_routing', None, True, ),  # 5
    (6, TType.I32, 'max_nums', None, 5000, ),  # 6
)
all_structs.append(HashGetResponse)
HashGetResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'members', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'values', (TType.STRUCT, [HashValue, None], False), None, ),  # 2
    (3, TType.STRUCT, 'error', [SharestoreException, None], None, ),  # 3
)
all_structs.append(MultiHashGetRequest)
MultiHashGetRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'types', (TType.I32, None, False), [
    ], ),  # 3
    (4, TType.LIST, 'members', (TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 4
    (5, TType.I32, 'max_nums', None, 5000, ),  # 5
    (6, TType.LIST, 'index', (TType.I32, None, False), None, ),  # 6
    (7, TType.BOOL, 'need_routing', None, True, ),  # 7
)
all_structs.append(MultiHashGetResponse)
MultiHashGetResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'responses', (TType.STRUCT, [HashGetResponse, None], False), None, ),  # 1
    (2, TType.LIST, 'sub_request_indices', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(HashIncrRequest)
HashIncrRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'members', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'values', (TType.I64, None, False), None, ),  # 4
    (5, TType.BOOL, 'need_routing', None, True, ),  # 5
)
all_structs.append(HashIncrResponse)
HashIncrResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [SharestoreException, None], None, ),  # 1
)
all_structs.append(HashCountRequest)
HashCountRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.I32, 'type', None, 0, ),  # 3
    (4, TType.BOOL, 'need_routing', None, True, ),  # 4
    (5, TType.I32, 'max_nums', None, 5000, ),  # 5
)
all_structs.append(HashCountResponse)
HashCountResponse.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'count', None, 0, ),  # 1
    (2, TType.STRUCT, 'error', [SharestoreException, None], None, ),  # 2
)
all_structs.append(HashExSetRequest)
HashExSetRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'members', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'values', (TType.STRUCT, [HashValue, None], False), None, ),  # 4
    (5, TType.I64, 'version', None, 0, ),  # 5
    (6, TType.LIST, 'ttl_secs', (TType.I32, None, False), None, ),  # 6
    (7, TType.BOOL, 'need_routing', None, True, ),  # 7
)
all_structs.append(HashExSetResponse)
HashExSetResponse.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'version', None, None, ),  # 1
    (2, TType.STRUCT, 'error', [SharestoreException, None], None, ),  # 2
)
all_structs.append(HashExRemRequest)
HashExRemRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.I32, 'type', None, 0, ),  # 3
    (4, TType.I64, 'version', None, 0, ),  # 4
    (5, TType.LIST, 'members', (TType.STRING, 'UTF8', False), None, ),  # 5
    (6, TType.BOOL, 'need_routing', None, True, ),  # 6
)
all_structs.append(HashExRemResponse)
HashExRemResponse.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'version', None, 0, ),  # 1
    (2, TType.STRUCT, 'error', [SharestoreException, None], None, ),  # 2
)
all_structs.append(HashExGetRequest)
HashExGetRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.I32, 'type', None, 0, ),  # 3
    (4, TType.LIST, 'members', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.BOOL, 'need_routing', None, True, ),  # 5
    (6, TType.I32, 'max_nums', None, 5000, ),  # 6
)
all_structs.append(HashExGetResponse)
HashExGetResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'members', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'values', (TType.STRUCT, [HashValue, None], False), None, ),  # 2
    (3, TType.I64, 'version', None, None, ),  # 3
    (4, TType.STRUCT, 'error', [SharestoreException, None], None, ),  # 4
)
all_structs.append(HashExIncrRequest)
HashExIncrRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'members', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'values', (TType.I64, None, False), None, ),  # 4
    (5, TType.I64, 'version', None, 0, ),  # 5
    (6, TType.BOOL, 'need_routing', None, True, ),  # 6
)
all_structs.append(HashExIncrResponse)
HashExIncrResponse.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'version', None, None, ),  # 1
    (2, TType.STRUCT, 'error', [SharestoreException, None], None, ),  # 2
)
all_structs.append(HashExCountRequest)
HashExCountRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.I32, 'type', None, 0, ),  # 3
    (4, TType.I64, 'version', None, 0, ),  # 4
    (5, TType.BOOL, 'need_routing', None, True, ),  # 5
    (6, TType.I32, 'max_nums', None, 5000, ),  # 6
)
all_structs.append(HashExCountResponse)
HashExCountResponse.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'count', None, 0, ),  # 1
    (2, TType.I64, 'version', None, None, ),  # 2
    (3, TType.STRUCT, 'error', [SharestoreException, None], None, ),  # 3
)
all_structs.append(ZSetAddRequest)
ZSetAddRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'members', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'scores', (TType.I64, None, False), None, ),  # 4
    (5, TType.LIST, 'ttl_secs', (TType.I32, None, False), None, ),  # 5
    (6, TType.BOOL, 'need_routing', None, True, ),  # 6
)
all_structs.append(ZSetAddResponse)
ZSetAddResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [SharestoreException, None], None, ),  # 1
)
all_structs.append(ZSetRemRequest)
ZSetRemRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'members', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.BOOL, 'need_routing', None, True, ),  # 4
)
all_structs.append(ZSetRemResponse)
ZSetRemResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [SharestoreException, None], None, ),  # 1
)
all_structs.append(ZSetGetRequest)
ZSetGetRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'with_scores', None, True, ),  # 3
    (4, TType.LIST, 'members', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.BOOL, 'need_routing', None, True, ),  # 5
    (6, TType.I32, 'max_nums', None, 5000, ),  # 6
)
all_structs.append(ZSetGetResponse)
ZSetGetResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'members', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'scores', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRUCT, 'error', [SharestoreException, None], None, ),  # 3
)
all_structs.append(IndexRange)
IndexRange.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'start', None, 0, ),  # 1
    (2, TType.I32, 'stop', None, -1, ),  # 2
)
all_structs.append(ScoreRange)
ScoreRange.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'min', None, 0, ),  # 1
    (2, TType.I64, 'max', None, 9223372036854775807, ),  # 2
)
all_structs.append(ZSetGetRangeRequest)
ZSetGetRangeRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    None,  # 2
    (3, TType.STRING, 'key', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'index_range', [IndexRange, None], None, ),  # 4
    (5, TType.STRUCT, 'score_range', [ScoreRange, None], None, ),  # 5
    (6, TType.BOOL, 'with_scores', None, True, ),  # 6
    (7, TType.BOOL, 'need_routing', None, True, ),  # 7
    (8, TType.I32, 'max_nums', None, 5000, ),  # 8
)
all_structs.append(ZSetGetRangeResponse)
ZSetGetRangeResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'members', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'scores', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRUCT, 'error', [SharestoreException, None], None, ),  # 3
)
all_structs.append(ZSetRemRangeRequest)
ZSetRemRangeRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'index_range', [IndexRange, None], None, ),  # 3
    (4, TType.STRUCT, 'score_range', [ScoreRange, None], None, ),  # 4
    (5, TType.BOOL, 'need_routing', None, True, ),  # 5
)
all_structs.append(ZSetRemRangeResponse)
ZSetRemRangeResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [SharestoreException, None], None, ),  # 1
)
all_structs.append(ZSetCountRequest)
ZSetCountRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'need_routing', None, True, ),  # 3
    (4, TType.I32, 'max_nums', None, 5000, ),  # 4
)
all_structs.append(ZSetCountResponse)
ZSetCountResponse.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'count', None, 0, ),  # 1
    (2, TType.STRUCT, 'error', [SharestoreException, None], None, ),  # 2
)
all_structs.append(ZSetScanRequest)
ZSetScanRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'segment', 'UTF8', "default", ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'cursor', 'BINARY', None, ),  # 3
    (4, TType.BOOL, 'with_scores', None, True, ),  # 4
    (5, TType.BOOL, 'is_reverse', None, False, ),  # 5
    (6, TType.BOOL, 'need_routing', None, True, ),  # 6
    (7, TType.I32, 'max_nums', None, 5000, ),  # 7
)
all_structs.append(ZSetScanResponse)
ZSetScanResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'members', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'scores', (TType.I64, None, False), None, ),  # 2
    (3, TType.STRING, 'cursor', 'BINARY', None, ),  # 3
    (4, TType.STRUCT, 'error', [SharestoreException, None], None, ),  # 4
)
fix_spec(all_structs)
del all_structs
